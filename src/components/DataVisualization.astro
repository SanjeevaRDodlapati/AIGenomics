---
// Interactive Data Visualization Component - Phase 3 Advanced Features
// Uses Chart.js for interactive data visualization
interface Props {
  title: string;
  type: 'line' | 'bar' | 'pie' | 'scatter';
  data: any;
  height?: string;
  showLegend?: boolean;
  interactive?: boolean;
  description?: string;
}

const { 
  title,
  type,
  data,
  height = '400px',
  showLegend = true,
  interactive = true,
  description
} = Astro.props;

const chartId = `chart-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="data-visualization bg-white border border-gray-200 rounded-lg p-6 mb-6">
  <!-- Chart Header -->
  <div class="mb-4">
    <h3 class="text-xl font-semibold text-gray-900 mb-2">{title}</h3>
    {description && (
      <p class="text-sm text-gray-600">{description}</p>
    )}
  </div>

  <!-- Chart Controls -->
  {interactive && (
    <div class="flex flex-wrap items-center gap-4 mb-4 p-3 bg-gray-50 rounded-lg">
      <div class="flex items-center space-x-2">
        <label for={`${chartId}-type`} class="text-sm font-medium text-gray-700">Chart Type:</label>
        <select 
          id={`${chartId}-type`}
          class="text-sm border border-gray-300 rounded px-2 py-1 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
        >
          <option value="line" selected={type === 'line'}>Line Chart</option>
          <option value="bar" selected={type === 'bar'}>Bar Chart</option>
          <option value="pie" selected={type === 'pie'}>Pie Chart</option>
          <option value="scatter" selected={type === 'scatter'}>Scatter Plot</option>
        </select>
      </div>
      
      <div class="flex items-center space-x-2">
        <button 
          id={`${chartId}-reset`}
          class="text-sm bg-gray-600 text-white px-3 py-1 rounded hover:bg-gray-700 transition-colors"
        >
          Reset Zoom
        </button>
      </div>

      <div class="flex items-center space-x-2">
        <button 
          id={`${chartId}-download`}
          class="text-sm bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 transition-colors flex items-center space-x-1"
        >
          <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
          </svg>
          <span>Download</span>
        </button>
      </div>
    </div>
  )}

  <!-- Chart Container -->
  <div class="relative" style={`height: ${height}`}>
    <canvas id={chartId} class="w-full h-full"></canvas>
    
    <!-- Loading State -->
    <div id={`${chartId}-loading`} class="absolute inset-0 flex items-center justify-center bg-white">
      <div class="flex items-center space-x-3 text-gray-600">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
        <span>Loading visualization...</span>
      </div>
    </div>
  </div>

  <!-- Chart Statistics -->
  <div id={`${chartId}-stats`} class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm hidden">
    <div class="bg-gray-50 p-3 rounded">
      <div class="text-gray-600 font-medium">Data Points</div>
      <div class="text-lg font-bold text-gray-900" id={`${chartId}-count`}>-</div>
    </div>
    <div class="bg-gray-50 p-3 rounded">
      <div class="text-gray-600 font-medium">Average</div>
      <div class="text-lg font-bold text-gray-900" id={`${chartId}-avg`}>-</div>
    </div>
    <div class="bg-gray-50 p-3 rounded">
      <div class="text-gray-600 font-medium">Maximum</div>
      <div class="text-lg font-bold text-gray-900" id={`${chartId}-max`}>-</div>
    </div>
    <div class="bg-gray-50 p-3 rounded">
      <div class="text-gray-600 font-medium">Minimum</div>
      <div class="text-lg font-bold text-gray-900" id={`${chartId}-min`}>-</div>
    </div>
  </div>
</div>

<script define:vars={{ chartId, type, data, showLegend, interactive }}>
  // Interactive Data Visualization using Chart.js
  class DataVisualization {
    constructor(chartId, initialType, data, showLegend, interactive) {
      this.chartId = chartId;
      this.initialType = initialType;
      this.data = data;
      this.showLegend = showLegend;
      this.interactive = interactive;
      
      this.canvas = document.getElementById(chartId);
      this.loading = document.getElementById(`${chartId}-loading`);
      this.stats = document.getElementById(`${chartId}-stats`);
      this.typeSelect = document.getElementById(`${chartId}-type`);
      this.resetBtn = document.getElementById(`${chartId}-reset`);
      this.downloadBtn = document.getElementById(`${chartId}-download`);
      
      this.chart = null;
      
      this.loadChart();
    }
    
    async loadChart() {
      try {
        // Load Chart.js if not already loaded
        if (typeof Chart === 'undefined') {
          await this.loadChartJS();
        }
        
        this.createChart();
        this.setupEventListeners();
        this.updateStatistics();
        this.hideLoading();
        
      } catch (error) {
        console.error('Failed to load chart:', error);
        this.showError('Failed to load visualization');
      }
    }
    
    async loadChartJS() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    
    createChart() {
      const ctx = this.canvas.getContext('2d');
      
      const config = {
        type: this.initialType,
        data: this.processData(this.data, this.initialType),
        options: this.getChartOptions()
      };
      
      if (this.chart) {
        this.chart.destroy();
      }
      
      this.chart = new Chart(ctx, config);
    }
    
    processData(rawData, chartType) {
      // Process data based on chart type
      switch (chartType) {
        case 'line':
        case 'bar':
          return {
            labels: rawData.labels || rawData.map((_, i) => `Point ${i + 1}`),
            datasets: [{
              label: rawData.label || 'Dataset',
              data: Array.isArray(rawData) ? rawData : rawData.values,
              backgroundColor: this.getBackgroundColor(chartType),
              borderColor: this.getBorderColor(chartType),
              borderWidth: 2,
              fill: chartType === 'line' ? false : true
            }]
          };
          
        case 'pie':
          return {
            labels: rawData.labels || rawData.map((_, i) => `Category ${i + 1}`),
            datasets: [{
              data: Array.isArray(rawData) ? rawData : rawData.values,
              backgroundColor: this.getPieColors(rawData.length || rawData.values?.length || 5)
            }]
          };
          
        case 'scatter':
          const scatterData = Array.isArray(rawData) ? rawData : rawData.points;
          return {
            datasets: [{
              label: rawData.label || 'Dataset',
              data: scatterData.map((point, i) => ({
                x: point.x || point[0] || i,
                y: point.y || point[1] || point
              })),
              backgroundColor: 'rgba(59, 130, 246, 0.6)',
              borderColor: 'rgb(59, 130, 246)'
            }]
          };
          
        default:
          return rawData;
      }
    }
    
    getChartOptions() {
      const baseOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: this.showLegend
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        }
      };
      
      if (this.interactive) {
        baseOptions.interaction = {
          mode: 'nearest',
          axis: 'x',
          intersect: false
        };
        
        if (this.initialType === 'line' || this.initialType === 'scatter') {
          baseOptions.plugins.zoom = {
            pan: {
              enabled: true,
              mode: 'x'
            },
            zoom: {
              wheel: {
                enabled: true
              },
              pinch: {
                enabled: true
              },
              mode: 'x'
            }
          };
        }
      }
      
      return baseOptions;
    }
    
    getBackgroundColor(chartType) {
      if (chartType === 'line') {
        return 'rgba(59, 130, 246, 0.1)';
      }
      return 'rgba(59, 130, 246, 0.8)';
    }
    
    getBorderColor(chartType) {
      return 'rgb(59, 130, 246)';
    }
    
    getPieColors(count) {
      const colors = [
        'rgba(59, 130, 246, 0.8)',   // Blue
        'rgba(16, 185, 129, 0.8)',   // Green
        'rgba(245, 158, 11, 0.8)',   // Yellow
        'rgba(239, 68, 68, 0.8)',    // Red
        'rgba(139, 92, 246, 0.8)',   // Purple
        'rgba(236, 72, 153, 0.8)',   // Pink
        'rgba(14, 165, 233, 0.8)',   // Sky
        'rgba(34, 197, 94, 0.8)',    // Emerald
      ];
      
      return colors.slice(0, count);
    }
    
    setupEventListeners() {
      if (!this.interactive) return;
      
      // Chart type selector
      this.typeSelect?.addEventListener('change', (e) => {
        this.changeChartType(e.target.value);
      });
      
      // Reset zoom button
      this.resetBtn?.addEventListener('click', () => {
        if (this.chart.resetZoom) {
          this.chart.resetZoom();
        }
      });
      
      // Download button
      this.downloadBtn?.addEventListener('click', () => {
        this.downloadChart();
      });
    }
    
    changeChartType(newType) {
      this.chart.config.type = newType;
      this.chart.config.data = this.processData(this.data, newType);
      this.chart.config.options = this.getChartOptions();
      this.chart.update();
      
      this.updateStatistics();
    }
    
    updateStatistics() {
      if (!this.stats) return;
      
      const values = this.getNumericValues();
      if (values.length === 0) return;
      
      const count = values.length;
      const sum = values.reduce((a, b) => a + b, 0);
      const avg = sum / count;
      const max = Math.max(...values);
      const min = Math.min(...values);
      
      document.getElementById(`${this.chartId}-count`).textContent = count.toLocaleString();
      document.getElementById(`${this.chartId}-avg`).textContent = avg.toFixed(2);
      document.getElementById(`${this.chartId}-max`).textContent = max.toFixed(2);
      document.getElementById(`${this.chartId}-min`).textContent = min.toFixed(2);
      
      this.stats.classList.remove('hidden');
    }
    
    getNumericValues() {
      const dataset = this.chart.data.datasets[0];
      
      if (Array.isArray(dataset.data)) {
        return dataset.data.filter(val => typeof val === 'number');
      }
      
      return [];
    }
    
    downloadChart() {
      const link = document.createElement('a');
      link.download = `${this.chartId}-chart.png`;
      link.href = this.canvas.toDataURL();
      link.click();
      
      // Track download event
      if (typeof gtag !== 'undefined') {
        gtag('event', 'chart_download', {
          'event_category': 'engagement',
          'event_label': this.chart.config.type,
          'value': 1
        });
      }
    }
    
    hideLoading() {
      if (this.loading) {
        this.loading.style.display = 'none';
      }
    }
    
    showError(message) {
      if (this.loading) {
        this.loading.innerHTML = `
          <div class="flex items-center space-x-3 text-red-600">
            <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <span>${message}</span>
          </div>
        `;
      }
    }
  }
  
  // Initialize visualization when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new DataVisualization(chartId, type, data, showLegend, interactive);
  });
</script>